# UlibCpp Documentation

This file contains the documentation for the UlibCpp library. Note that the
source code shown may not represent the actual source code. Please refer to
the actual files when details are unclear.

Please use the table of contents to navigate the document:

[Configuration](#configuration)<br/>
[Core header](#core-header)<br/>
[Logging](#logging)<br/>
[Stream](#stream)<br/>
[Threading](#threading)<br/>
[Win32 API](#win32-api)<br/>

## Configuration

These header files simplify the configuration of project types, e.g. WTL
projects.

`#include <ulib/config/Common.hpp>`

Defines the following:

- macro `UNUSED(x)`: Can be used in function signatures to suppress the
  warning about unused parameters, e.g.:

      void DoSomething(int arg1, CString arg2)
      {
          UNUSED(arg2);
      }

- `sizeof_array(x)`: determines the size of the array x, in number of
  elements:

      int allItems[] = { 1, 2, 3, 4, 5 };
      for (size_t index = 0; index < sizeof_array(allItems); index++) ...

`Common.hpp` also includes:

`#include <ulib/config/CompileTimeWarningError.hpp>`

Defines the following:

- macro `ULIB_COMPILE_WARN(text)`: Outputs a warning in the compiler output;
  use it like this:

      #pragma ULIB_COMPILE_WARN("Check warning here")

- macro `ULIB_COMPILE_ERROR(text)`: Outputs an error in the compiler output;
  use it like this:

      #pragma #pragma ULIB_COMPILE_ERROR("C9999", "Don't forget to code here!")

`#include <ulib/config/Win32.hpp>`

Includes all sorts of Win32 API headers. This is the base of `Atl.hpp`. Check
the file contents for details.

`#include <ulib/config/Atl.hpp>`

Includes for an ATL based project. This is the base of `Wtl.hpp`. Check the
file contents for details.

`#include <ulib/config/Wtl.hpp>`

Includes for a WTL based project. Most WTL projects generated by the WTL
wizard can just include this file instead of the many ATL and WTL files in the
generated `stdafx.h` file. The necessary order of ATL and WTL headers are
ensured. Check the file contents for details.

`#include <ulib/config/BoostAsio.hpp>`

Includes the Boost header `<boost/asio.hpp>` and prevents default linking to
some Boost libraries; also disables warnings from the included headers. The
header also prevents auto-generating a WinSock-init class, which automatically
pulls in a dependency to the `winsock2.dll`.

`#include <ulib/config/BoostDateTime.hpp>`

Includes the Boost header `<boost/date_time.hpp>`, disables warnings and
also prevents linking to the `Boost.DateTime` library.

`#include <ulib/config/Android.hpp>`

Defines some types like `LPCTSTR` and macros like `ATLASSERT`, `ATLTRACE`,
etc., to be able to compile code that uses ATL or WTL data types under an
Android C++ project type. This header is experimental and currently misses a
`CString` implementation.

## Core header

The root ulib include folder contains some often used classes.

`#include <ulib/ulib.hpp>`

This include file includes all other headers. Only use this if you use almost
all of the library. Instead include single headers when you use specific
classes.

### Miscellaneous

#### Crash reporting

`#include <ulib/CrashReporter.hpp>`

Provides a single static function that initializes the crash reporter:

    static void CrashReporter::Init(
       const CString& appName, const CString& basePath,
       T_fnShowCrashDialog fnShowCrashDialog = T_fnShowCrashDialog());

The crash reporter catches any unhandled C++ exceptions and calls to
`std::terminate()` and writes a minidump crash dump file (extension .mdmp) to
a folder. The minidump file is stored in the `basePath` folder and the
`appName` is used as prefix for the filename. An optional function with the
following signature can be passed:

    void ShowCrashDialog(LPCTSTR filename);

The function is called after writing the minidump crash dump file in order to
show the user a dialog. Depending on the cause of the crash, the function may
not be called at all (e.g. due out of memory errors).

#### Dynamic library loading

`#include <ulib/DynamicLibrary.hpp>`

Provides a RAII helper class to load dynamic libraries (DLLs) and get function
pointers exported by it:

    class DynamicLibrary
    {
    public:
       /// ctor; loads module
       DynamicLibrary(LPCTSTR moduleFilename);
       /// dtor; frees module again
       ~DynamicLibrary();

       /// checks if library is loaded
       bool IsLoaded() const;

       /// checks if function with given name is available
       bool IsFunctionAvail(LPCSTR functionName) const;

       /// returns function with given function name and given function signature
       template <typename Signature>
       Signature GetFunction(LPCSTR functionName) const;
    };

#### Exception handling

`#include <ulib/Exception.hpp>`

This header contains an Exception class that is used whenever ulib throws an
exception and is derived from `std::exception`.

    class Exception : public std::exception
    {
    public:
       Exception(LPCSTR sourceFile, UINT sourceLine);
       Exception(const CString& message, LPCSTR sourceFile, UINT sourceLine);

       CString Message() const;
       CString SourceFile() const;
       UINT SourceLine();
    };

The exception message can also be retrieved with the base classes `what()`
method.

#### File finder

`#include <ulib/FileFinder.hpp>`

The class `FileFinder` helps with enumerating files. It has a static
convenience method that does everything:

    static std::vector<CString> FindAllInPath(
       const CString& path, const CString& fileSpec, bool findFolders, bool recursive);

The `fileSpec` may contain wildcards, like `*.*`, `*.png` or `IMG????.jpg`.
The flag `findFolders` indicates if folders should be found instead of files.
The flag `recursive` specifies if folders should be recursively searched.

The class can also be used manually:

    class FileFinder
    {
    public:
       FileFinder(const CString& baseFolder, const CString& fileSpec);

       /// indicates if any files were found
       bool IsValid() const;

       /// returns if the current file entry is a dot file, "." or ".."
       bool IsDot() const;

       /// returns if current file entry is a file
       bool IsFile() const;

       /// returns if current file entry is a folder
       bool IsFolder() const;

       /// returns complete filename of current file entry
       CString Filename() const;

       /// retrieves next file entry
       bool Next();
    };

Constructing the class already starts the search, so it's best to use it in a
`do-while` loop:

    FileFinder finder{ baseFolder, "*.*" };
    if (finder.IsValid())
    do
    {
       if (finder.IsDot())
          continue;
       ATLTRACE(_T("path: %s\n"), finder.Filename().GetString());
    } while (!finder.Next());

#### IoC Container

`#include <ulib/IoCContainer.hpp>`

This class provides an IoC (inversion of control) container that stores
references to objects in a central place.

    class IoCContainer
    {
    public:
       /// returns current instance of IoC container
       static IoCContainer& Current();

       /// registers reference for class
       template <typename TClass>
       void Register(boost::reference_wrapper<TClass> ref);

       /// resolves class to object
       template <typename TInterface>
       TInterface& Resolve();
    };

At the start of the app, `Register()` any objects that should be globally
available, and resolve them using `Resolve()` at a later time.

#### Observer pattern

`#include <ulib/Observer.hpp>`

This header provides an implementation of the Observer pattern, much like the
C# event functionality. The `Subject` is the source of an event being sent to
zero, one or more observer functions.

    template <typename T>
    class Subject
    {
    public:
       /// function type to be called
       typedef std::function<T> T_fnSubject;

       /// adds new observer; new ID is returned
       int Add(std::function<T> fnObserver);

       /// adds new observer
       Subject<T>& operator+=(std::function<T> fnObserver);

       /// removes an observer by ID
       void Remove(int id);

       /// calls subject with zero arguments
       void Call();

       /// calls subject with one arguments
       template <typename T1>
       void Call(T1 param1);

       /// calls subject with two arguments
       template <typename T1, typename T2>
       void Call(T1 param1, T2 param2);

       /// removes all observer
       void Clear();
    };

`T` is the function signature of the observer functions. Define a subject
like this:

    Subject<void(const Widget& senderObject, const EventArgs& eventArgs)> m_buttonClicked;

In the code, set up an observer function or lambda:

    m_buttonClicked += [] (senderObject, eventArgs) { /* do something here */ }

The `Add()` method returns an `int` ID that can be used to remove observers
again.

#### Path handling

`#include <ulib/Path.hpp>`

This header provides the `Path` class with static methods to manipulate folder
or file paths.

    class Path
    {
    public:
       /// returns filename and extension
       static CString FilenameAndExt(const CString& path);

       /// returns filename without extension
       static CString FilenameOnly(const CString& path);

       /// returns extension only, with leading dot
       static CString ExtensionOnly(const CString& path);

       /// returns folder name, without filename, but ending slash
       static CString FolderName(const CString& path);

       /// returns short path name (filename in 8.3 format); file must actually exist
       static CString ShortPathName(const CString& path);

       /// make path relative to the given root path and returns it
       static CString MakeRelativeTo(const CString& path, const CString& rootPath);

       /// returns if stored path is a relative path
       static bool IsRelative(const CString& path);

       /// returns if path represents a file and if it exists
       static bool FileExists(const CString& path);

       /// returns if path represents a folder and if it exists
       static bool FolderExists(const CString& path);

       /// canonicalizes path by removing '..', etc.
       static bool Canonicalize(CString& path);

       /// adds a backslash at the end of the path
       static void AddEndingBackslash(CString& path);

       /// combine both path parts and return new path
       static CString Combine(const CString& part1, const CString& part2);

       /// returns the common root path of both given paths; returns empty string when there's no common root
       static CString GetCommonRootPath(const CString& path1, const CString& path2);

       /// returns special folder; see CSIDL_* constants
       static CString SpecialFolder(int csidl);

       /// returns the windows folder
       static CString WindowsFolder();

       /// returns the temp folder
       static CString TempFolder();

       /// returns file name of given module name (e.g. kernel32.dll); nullptr means the currently running .exe module
       static CString ModuleFilename(HMODULE moduleHandle = nullptr);

       /// creates a directory, possibly also creating non-existent parent directories
       static bool CreateDirectoryRecursive(LPCTSTR directoryName);

       // public members

       /// path separator string
       static const TCHAR Separator[2];

       /// path separator character
       static const TCHAR SeparatorCh = _T('\\');
    }

#### Singleton

`#include <ulib/Singleton.hpp>`

Provides a thread-safe singleton pattern implementation.

    class WidgetManager : public Singleton<WidgetManager>
    {
       // ...
    };

The singleton instance can then be accessed with:

    WidgetManager& manager = WidgetManager::Instance();

In a .cpp file, declare the implementation of the singleton like this:

    IMPLEMENT_SINGLETON(WidgetManager)

This defines the static variables needed to provide the singleton instance.

#### System exception

`#include <ulib/SystemException.hpp>`

An exception that additionally stores a Win32 error code:

    class SystemException : public Exception
    {
    public:
       /// ctor
       SystemException(const CString& message, DWORD win32ErrorCode, LPCSTR sourceFile, UINT sourceLine);

       /// returns win32 error code
       DWORD Win32Error() const
    };

#### UTF-8 conversion

`#include <ulib/UTF8.hpp>`

This header provides UTF-8 conversion functions:

    /// converts string to UTF-8 encoding
    void StringToUTF8(const CString& text, std::vector<char>& utf8Buffer);

    /// converts from UTF-8 encoded text to CString
    CString UTF8ToString(const char* utf8Text);

The UlibCpp library is compiled using the `UNICODE` define, so CString can
always hold the UTF-8 encoded string.

#### Command line parsing

`#include <ulib/CommandLineParser.hpp>`

The `CommandLineParser` simplifies parsing command line parameters and also
supports parsing arguments in double quotes, e.g. path names with spaces.

    class CommandLineParser
    {
    public:
       /// parses single long command line string
       CommandLineParser(const CString& commandLine = GetCommandLine());

       /// parses _tmain parameter
       CommandLineParser(int argc, TCHAR* argv[]);

       /// returns next parameter
       bool GetNext(CString& nextParameter);
    };

The first parameter is always the executable's file path. The class can easily
be used in a while loop:

    CommandLineParser parser;
    CString parameter;
    while (parser.GetNext(parameter))
    {
       // do something with parameter
    }

#### Program options

`#include <ulib/ProgramOptions.hpp>`

The `ProgramOptions` class extends the command line parsing and provides a
way to specify all options of a program and then lets the class parse the
command line by itself.

As a first step, register an output handler:

    ProgramOptions options;
    options.RegisterOutputHandler([] (const CString& text) { _tprintf(text); });

You can also use the provided `OutputConsole` function:

    options.RegisterOutputHandler(&ProgramOptions::OutputConsole);

You can also decide to collect the output in a string and show a message box,
or use any other output mechanism.

If you want to show the user help text when `/h`, `/?` or `--help` is
specified, use:

    options.RegisterHelpOption();

Now register one or more parameters that you want to handle. This call
registers an option `-i` with long variant `--ignore-case`, a help text and
without further arguments:

    options.RegisterOption(_T("i"), _T("ignore-case"),
       _T("Ignores case on comparisons"),
       [] () { m_ignoreCase = true; return true; });

This call registers an option with a single argument:

    options.RegisterOption(_T("o"), _T("output"),
       _T("Specifies the output folder"),
       [] (const CString& arg) { m_outputFolder = arg; return true; });

This registers an option with multiple arguments:

    options.RegisterOption(_T("d"), _T("define"),
       _T("Defines a key with a value (2 arguments)"),
       2,
       [] (const std::vector<CString>& args) { /* do something with args */ });

The first two `RegisterOptions()` calls can also be written as:

    options.RegisterOption(_T("i"), _T("ignore-case"),
       _T("Ignores case on comparisons"),
       m_ignoreCase);

    options.RegisterOption(_T("o"), _T("output"),
       _T("Specifies the output folder"),
       m_outputFolder);

The `m_ignoreCase` and `m_outputFolder` variables are taken by reference
and are assigned appropriately while parsing.

Finally, call one of the `Parse()` functions:

    /// parses command line options, C-style
    void Parse(int argc, _TCHAR* argv[]);

    /// parses command line options, Win32-style
    void Parse(LPCTSTR commandLine);

When the user specified one of the help options, a help text is output, based
on the help texts specified in the `RegisterOption()` calls. You can check
for the help option and quit the app without starting up by checking
`IsSelectedHelpOption()`:

    if (options.IsSelectedHelpOption())
       return 0;

#### Date/time handling

These headers define date/time related classes.

`#include <ulib/DateTime.hpp>`

The class `DateTime` defines a point in time, with date and time parts. The
point in time is time zone agnostic and usually stored as local time. Be sure
to store dates as UTC in external systems (like databases) that may be running
in different time zones.

A `DateTime` object can be created in several ways:

    /// date/time status values
    enum T_enStatus { valid = 0, invalid, min, max };

    /// default ctor; initialized with invalid status
    DateTime();

    /// ctor; takes date/time components
    DateTime(unsigned int year, unsigned int month, unsigned int day,
       unsigned int hour, unsigned int minute, unsigned int second,
       unsigned int millisecond = 0);

    /// ctor; initialize with min or max status
    DateTime(T_enStatus status);

    /// returns current date/time
    static DateTime Now();

    /// returns current date with time part set to 00:00:00
    static DateTime Today();

    /// returns max time value
    static DateTime MaxValue() { return DateTime(DateTime::max); }

    /// returns min time value
    static DateTime MinValue() { return DateTime(DateTime::min); }

The date can also be modified using these methods:

    /// sets date/time components
    void SetDateTime(unsigned int year, unsigned int month, unsigned int day,
       unsigned int hour, unsigned int minute, unsigned int second,
       unsigned int millisecond = 0);
 
    /// parses ISO 8601 formatted date/time
    void ParseISO8601(const CString& iso8601Timestamp);

The properties of the date/time point can also be accessed with these getters:

    /// returns date/time status
    T_enStatus Status() const;
    /// returns year
    unsigned int Year() const;
    /// month of year; 1 = january
    unsigned int Month() const;
    /// day of month (1-31)
    unsigned int Day() const;

    /// hour in day (0-23)
    unsigned int Hour() const;
    /// minute in hour (0-59)
    unsigned int Minute() const;
    /// second in minute (0-59)
    unsigned int Second() const;
    /// millisecond in second (0-999)
    unsigned int Millisecond() const;

    /// day of week; 0: sunday; ... 6: saturday
    unsigned int DayOfWeek() const;
    /// day of year; 1-based
    unsigned int DayOfYear() const;
    /// returns time part of date
    TimeSpan TimeOfDay();

There are also operators for addition and subtraction of `TimeSpan` and
comparison operators with `DateTime`, not shown here.

Formatting dates as text can be done with these methods:

    /// ISO 8601 format
    enum T_enISO8601Format
    {
       formatY,       // year only
       formatYM,      // year and month
       formatYMD,     // year and month
       formatYMD_HM_Z,   // year, month, day, hour, minute and timezone offset
       formatYMD_HMS_Z,  // year, month, day, hour, minute, second and timezone offset
       formatYMD_HMSF_Z, // full date/time with fraction and timezone offset
    };

    /// formats date/time using ISO 8601 format
    CString FormatISO8601(T_enISO8601Format enFormat = formatYMD_HMS_Z, bool bBasic = false,
        const TimeZone& tz = TimeZone::System()) const;

    /// formats date/time with given format, see _tcsftime
    CString Format(const CString& format, const TimeZone& tz = TimeZone::System()) const;

Note: Use UTC timezone if the date should be stored in external systems (like
databases) when it could be used in multiple time zones.

`#include <ulib/TimeSpan.hpp>`

The class `TimeSpan` defines a time span that can be positive or negative.

A `TimeSpan` object can be created in several ways:

    /// time span status values
    enum T_enStatus { valid = 0, invalid, min, max };

    /// default ctor
    TimeSpan();

    /// ctor; takes date/time span components
    TimeSpan(int hours, int minutes, int seconds, int milliseconds = 0);

    /// ctor; initialize with min or max status only
    TimeSpan(T_enStatus status);

    /// sets time span components
    void SetDateTimeSpan(int hours, int minutes, int seconds, int milliseconds);

The properties of the time span can also be accessed with these getters:

    /// returns date/time status
    T_enStatus Status() const;

    /// component hours in span (-23 to 23)
    int Hours() const;
    /// component minutes in span (-59 to 59)
    int Minutes() const;
    /// component seconds in span (-59 to 59)
    int Seconds() const;
    /// component milliseconds in span (-999 to 999)
    int Milliseconds() const;

    /// span in hours (about -8.77e7 to 8.77e6)
    double TotalHours() const;
    /// span in minutes (about -5.26e9 to 5.26e9)
    double TotalMinutes() const;
    /// span in seconds (about -3.16e11 to 3.16e11)
    double TotalSeconds() const;
    /// span in milliseconds
    double TotalMilliseconds() const;

There are also operators for addition and subtraction of `TimeSpan` and
comparison operators with `TimeSpan`, not shown here.

Formatting time spans as text can be done with these methods:

    /// time span format
    enum T_enTimeSpanFormat
    {
       formatHMS,     // "hh:mm:ss" format
       formatISO8601, // ISO 8601, "PTxxHxxMxxS" format
    };

    /// formats time span using specified format
    CString Format(T_enTimeSpanFormat format = formatHMS) const;

    /// formats time span using given format, see _tcsftime
    CString Format(LPCTSTR format) const;

`#include <ulib/TimeZone.hpp>`

The class `TimeZone` defines a time zone that can be used when formatting
`DateTime`objects as text.

Time zones can be accessed with these static methods:

    /// returns UTC timezone
    static TimeZone TimeZone::UTC();

    /// returns current system's timezone
    static TimeZone TimeZone::System();

    /// enumerates all timezones in the system
    static std::vector<TimeZone> TimeZone::EnumerateTimezones();

The `TimeZone` class can be accessed for further infos:

    class TimeZone
    {
    public:
       /// returns timezone name during daylight savings time
       CString DaylightName() const;

       /// returns timezone name during standard time
       CString StandardName() const;

       /// returns display name for timezone when enumerating all system timezones
       CString DisplayName() const;

       /// gets UTC offset for given date/time
       TimeSpan GetUtcOffset(const DateTime& dt) const;

       /// returns if date/time is in daylight savings time
       bool IsDaylightSavingTime(const DateTime& dt) const;
    };

#### Timer classes

`#include <ulib/Timer.hpp>`

The `Timer` class can be used to measure running time, e.g. for statistics or
debugging purposes. The class has a precision of about 15 ms.

    class Timer
    {
    public:
       /// ctor
       Timer();

       /// starts timer; timer must be stopped or reset
       void Start();

       /// stops timer; timer must be started
       void Stop();

       /// resets timer; timer must be stopped
       void Reset();

       /// restarts timer by resetting and starting again
       void Restart();

       /// returns elapsed time since Start() was called, in seconds
       double Elapsed() const;

       /// returns total elapsed time in seconds
       double TotalElapsed() const;

       /// returns if timer is running
       bool IsStarted() const;
    };

`Elapsed()` only considers the last `Start()` call, whereas `TotalElapsed()`
also returns the accumulated time from previous start/stop cycles.

`#include <ulib/HighResolutionTimer.hpp>`

The `HighResolutionTimer` has the exact same interface as the `Timer` class,
but has a higher resolution, as it uses the CPU's Performance Counters.

`#include <ulib/TraceOutputStopwatch.hpp>`

Both `Timer` and `HighResolutionTimer` classes can be used as types in the
`TraceOutputStopwatch` class that automatically provides trace output. Use it
like this:

    TraceOutputStopwatch<HighResolutionTimer> renderStopwatch{ _T("renderTime") };

The ctor and the dtor of the class both call `ATLTRACE()` to output start and
stop of the timer, and the elapsed time in a readable format.

## Logging

The `log` include folder contains classes for logging. It's not as thorough
as e.g. log4cxx, but often enough for smaller applications.

Logging involves the following concepts:

- Log level: Determines how severe a log message is
- Log message: The message text itself
- Log category: A tree-like hierarchy of loggers that determine what messages
  get logged where
- Layout: Determines how the log text is to be formatted
- Appender: Determines where the log text is going to be written or sent

Log categories are organized like a tree, and each tree node and leaf are an
instance of a `Logger` class. Here are some log categories, the tree "branches"
separated with dots:

    client
    client.renderer
    client.import
    client.import.audio
    client.import.models

The logger `client` sits at the root and has the loggers `renderer` and
`import`. The `import` logger again has two loggers `audio` and `models`.
Depending on the use cases, I can now log to one of the listed loggers:

    LOG_DEBUG(_T("rendering finished"), _T("client.renderer"));

Loggers are created on-the-fly if they are not found in the (root) logger's
tree. You can get a logger directy, e.g. like this:

    auto root = Log::Logger::GetRootLogger();
    auto logger = root->GetLogger("client.renderer");

Each logger can have one or more `Appender` that determines what to do with
log messages that are logged to this logger. Each appender has a `Layout`
object that determines how to format the log message. Setting this up on a
specific logger looks like this:

    auto patternLayout = std::make_shared<Log::PatternLayout>(_T("%F(%L): log [%p] %m"));
    auto debugAppender = std::make_shared<Log::OutputDebugStringAppender>();
    debugAppender->Layout(patternLayout);

    auto rendererLogger = Log::Logger::GetRootLogger()->GetLogger("client.renderer")
    rendererLogger->AddAppender(debugAppender);

Note that a logger, and also the root logger, has no appender by default. You
have to configure this before you can see any logging output.

The default behavior of each logger is to also send the log event to the
parent logger, in this case `client`, which may also log the message. This can
be changed on a by-logger basis and is called "additivity". For example, the
`client.renderer` messages shouldn't reach the `client` logger, since they
are only for debug console output:

    auto logger = Log::Logger::GetRootLogger()->GetLogger("client.renderer");
    logger->Additivity(false);

Each logger can also be configured to only log messages of a specific severity
or higher. The `client.import` (and all of those below) may only get
LOG_ERROR messages or above, to not degrade performance:

    auto logger = Log::Logger::GetRootLogger()->GetLogger("client.import");
    logger->Level(Log::Level::error);

`#include <ulib/log/Log.hpp>`

This header defines some common types used for logging, among them the log
levels:

    namespace Log
    {
       enum Level
       {
          debug = 0,
          info,
          warn,
          error,
          fatal,
          none,
       };
    }

### Logger class

`#include <ulib/log/Logger.hpp>`

This header files defines the `Logger` class that implements a logger that
can be part of a logger hierarchy.

    namespace Log
    {
       class Logger
       {
       public:
          // properties

          /// returns logger level
          Level Level() const;

          /// returns additivity flag
          bool Additivity() const;

          /// returns parent logger
          LoggerPtr Parent();

          /// returns full logger name
          CString Name();

          /// sets logger level
          void Level(Log::Level level);

          /// sets additivity
          void Additivity(bool additivity);

          // methods

          /// returns root logger
          static LoggerPtr GetRootLogger();

          /// returns logger with given name
          static LoggerPtr GetLogger(const CString& name);

          /// adds appender to this logger
          void AddAppender(AppenderPtr appender);

          /// removes all appender from this logger
          void RemoveAllAppender();

          /// removes given appender
          void RemoveAppender(AppenderPtr appender);
       };
    }

The header file also defines macros used for logging:

    LOG_DEBUG(msg, cat)
    LOG_INFO(msg, cat)
    LOG_WARN(msg, cat)
    LOG_ERROR(msg, cat)
    LOG_FATAL(msg, cat)

The `msg` parameter is a text that should be logged, and `cat` is a category
to be logged under. The category determines where in the logger hierarchy the
logged text is sent to.

`#include <ulib/log/LoggingEvent.hpp>`

The `LoggingEvent` class encapsulates properties of the logging event.
Normally you won't get in touch with the class. See the header file for
details.

### Layout class

`#include <ulib/log/Layout.hpp>`

The `Layout` class formats the logging event for output in an appender. You
can derive from this class in order to have a custom layout.

    namespace Log
    {
       class Layout
       {
       public:
          virtual ~Layout();

          /// appends header to output; override when necessary
          virtual void AppendHeader(CString& outputText);

          /// appends footer to output; override when necessary
          virtual void AppendFooter(CString& outputText);

          /// formats logging event to string
          virtual void Format(CString& outputText, const LoggingEventPtr loggingEvent) = 0;
       };
    }

Only the `Format()` method is mandatory to override. `AppendHeader()` and
`AppendFooter()` methods are called for appender that want to put a header
and/or a footer line in a log file.

### SimpleLayout class

`#include <ulib/log/SimpleLayout.hpp>`

The `SimpleLayout` class is derived from the `Layout` class and simply
formats the output text using the log level in capital letters, a dash and the
log text, e.g.:

    DEBUG - Render thread took 12.3 ms.

### PatternLayout class

`#include <ulib/log/PatternLayout.hpp>`

The `PatternLayout` class is derived from the `Layout` class and lets you
specify a printf-like pattern to specify how the log text should be formatted.

A pattern string consists of text and pattern specifiers that start
with the % char and end with a pattern character, similar to the printf
notation. The following characters have meaning:

- c: outputs logger name
- d: date in ISO 8601 format
- F: source filename where log message occured
- l: not supported
- L: source file line where log message occured
- m: log message; not supported
- n: platform-specific newline character
- p: log level (priority)
- r: not supported
- t: thread id
- %: percent sign

The following format modifiers are allowed:
- The - adds left justification to the string
- Next comes the minimum field width (excess space is padded)
- Optional . (dot)
- Next comes the maximum field width; if string is larger, the last n characters are shown

The class only has a ctor that lets you specify the pattern:

    namespace Log
    {
       class PatternLayout : public Layout
       {
       public:
          PatternLayout(const CString& pattern);
       };
    }

### Appender class

`#include <ulib/log/Appender.hpp>`

The `Appender` class is the base class for all appenders that can write the
formatted log text to a target. Each appender can have a different `Layout`
class set. Override this class to implement your own appender.

    namespace Log
    {
       class Appender
       {
       public:
          virtual ~Appender();

          /// returns layout object being used
          LayoutPtr Layout();

          /// sets new layout object
          void Layout(LayoutPtr layout);

          /// appends logging event to output
          virtual void DoAppend(const LoggingEventPtr loggingEvent) = 0;
       };
    }

### ConsoleAppender class

`#include <ulib/log/ConsoleAppender.hpp>`

The `ConsoleAppender` is derived from the `Appender` class and lets you write
the log text to the console using printf.

    namespace Log
    {
       class ConsoleAppender : public Appender
       {
       public:
          virtual ~ConsoleAppender();
          virtual void DoAppend(const LoggingEventPtr loggingEvent);
       };
    }

### OutputDebugStringAppender class

`#include <ulib/log/OutputDebugStringAppender.hpp>`

The `OutputDebugStringAppender` is derived from the `Appender` class and
uses the Win32 API function OutputDebugString to write the log text to the
debugger. The log text can also be intercepted with tools like the
SysInternal's Process Monitor.

    namespace Log
    {
       class OutputDebugStringAppender : public Appender
       {
       public:
          virtual ~OutputDebugStringAppender();
          virtual void DoAppend(const LoggingEventPtr loggingEvent);
       };
    }

### TextStreamAppender class

`#include <ulib/log/TextStreamAppender.hpp>`

The `TextStreamAppender` is derived from the `Appender` class and can write
the log text to a `Stream::ITextStream` instance. See the "Streams" chapter
for more infos on the `ITextStream` interface.

    namespace Log
    {
       class TextStreamAppender : public Appender
       {
       public:
          TextStreamAppender(std::shared_ptr<Stream::ITextStream> textStream);
          virtual ~TextStreamAppender();
          virtual void DoAppend(const LoggingEventPtr loggingEvent);
       };
    }

### AndroidLogcatAppender class

`#include <ulib/log/AndroidLogcatAppender.hpp>`

The `AndroidLogcatAppender` is derived from the `Appender` class and can
write the log text to the Android logcat facility. This class can only be used
when compiling and linking an Android C++ project type.

    namespace Log
    {
       class AndroidLogcatAppender : public Appender
       {
       public:
          virtual ~AndroidLogcatAppender();
          virtual void DoAppend(const LoggingEventPtr loggingEvent);
       };
    }

## Stream

## Threading

## Unit test support

## Win32 API
